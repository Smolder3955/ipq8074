// vim: set et sw=4 sts=4 cindent:
/*
 * @File: wlanif.h
 *
 * @Abstract: Load balancing daemon WLAN interface
 *
 * @Notes:
 *
 * @@-COPYRIGHT-START-@@
 *
 * Copyright (c) 2014-2018 Qualcomm Technologies, Inc.
 *
 * All Rights Reserved.
 * Confidential and Proprietary - Qualcomm Technologies, Inc.
 *
 * 2014-2016 Qualcomm Atheros, Inc.
 *
 * All Rights Reserved.
 * Qualcomm Atheros Confidential and Proprietary.
 *
 * @@-COPYRIGHT-END-@@
 */

#ifndef wlanif__h
#define wlanif__h

#include <netinet/ether.h>

#include "lbd_types.h"

/*
 * lock for guarding the vap setup routines.
 */
#define HYD_MY_LOCK "/tmp/.vap_seting_lock"


// ====================================================================
// Types exposed purely for logging purposes
// ====================================================================

/**
 * @brief The diagnostic logging message IDs generated by this module.
 */
typedef enum wlanif_msgId_e {
    /// Raw utilization measurement: 8-bit band + 8-bit utilization
    wlanif_msgId_rawChanUtilization,

    /// Raw RSSI measurement: MAC + 8-bit band + 8-bit RSSI
    wlanif_msgId_rawRSSI,

    /// Interface information
    wlanif_msgId_interface,

    /// Beacon report: MAC + reportedBSS + 8-bit RCPI
    wlanif_msgId_beaconReport,
} wlanif_msgId_e;

// ====================================================================
// Common types exported to other modules
// ====================================================================

#define WLANIF_MAX_OPERATING_CLASSES 20

#define WLANIF_MAX_CHANNELS_PER_OP_CLASS 16

#define WLANIF_MAX_SSID_LEN 32

#define WLANIF_MAX_RADIOS 3  // looking forward to tri-radio platforms

/**
 * @brief Type that denotes the Wi-Fi band.
 *
 * This type is only for use within the Load Balancing Daemon.
 */
typedef enum wlanif_band_e {
    wlanif_band_24g,   ///< 2.4 GHz
    wlanif_band_5g,    ///< 5 GHz
    wlanif_band_invalid,  ///< band is not known or is invalid
} wlanif_band_e;

/**
 * @brief IDs of events that are generated from this module.
 */
typedef enum wlanif_event_e {
    wlanif_event_probereq,    ///< RX'ed probe request
    wlanif_event_authrej,     ///< TX'ed authentication message with failure

    wlanif_event_act_change,  ///< RX'ed activity change

    wlanif_event_assoc,       ///< A client associated
    wlanif_event_disassoc,    ///< A client disassociated

    wlanif_event_chan_util,   ///< Channel utilization measurement
    wlanif_event_vap_restart, ///< VAP was restarted (eg. due to channel
                              ///< change or a down/up)

    wlanif_event_rssi_xing,   ///< RSSI crossing threshold

    wlanif_event_rssi_measurement, ///< RSSI measurement

    wlanif_event_band_steering_state,  ///< Band steering on/off change

    wlanif_event_btm_response, ///< RX'ed BSS Transition Management response frame

    wlanif_event_beacon_report,  ///< 802.11k beacon report received

    wlanif_event_beacon_frame_report,  ///< 802.11k beacon report received

    wlanif_event_tx_rate_xing,   ///< Tx rate crossing threshold

    wlanif_event_smps_update,    ///< SM Power Save mode update

    wlanif_event_opmode_update,  ///< Operating Mode update

    wlanif_event_btm_query, ///< RX'ed BSS Transition Management query frame

    wlanif_event_radio_oper_chan_update,  ///< Radio operating channel update

    wlanif_event_rssi_xing_map,   ///< RSSI crossing threshold MAP

    wlanif_event_classgroup_update, ///< Classification group update

    wlanif_event_maxnum
} wlanif_event_e;

/**
 * @brief The format of the wlanif_event_probereq event.
 */
typedef struct wlanif_probeReqEvent_t {
    /// Address of the STA that sent the probe request.
    struct ether_addr sta_addr;

    /// The BSS on which the probe request was sent.
    lbd_bssInfo_t bss;

    /// The measured RSSI of the probe request.
    u_int8_t rssi;
} wlanif_probeReqEvent_t;

/**
 * @brief The format of the wlanif_event_authrej event.
 */
typedef struct wlanif_authRejEvent_t {
    /// Address of the STA that sent the authentication message and that
    /// is being refused admission due to an ACL.
    struct ether_addr sta_addr;

    /// The BSS on which the message was sent.
    lbd_bssInfo_t bss;

    /// The measured RSSI of the received authentication message.
    u_int8_t rssi;
} wlanif_authRejEvent_t;

/**
 * @brief The format of the wlanif_event_act_change event.
 */
typedef struct wlanif_actChangeEvent_t {
    /// Address of the STA whose activity status changed.
    struct ether_addr sta_addr;

    /// BSS on which the change occurred
    lbd_bssInfo_t bss;

    /// The activity status
    LBD_BOOL active;
} wlanif_actChangeEvent_t;

/**
 * @brief Type of update of STA capability state
 */
typedef enum wlanif_capStateUpdate_e {
    wlanif_cap_enabled = 0,
    wlanif_cap_disabled = 1,
    wlanif_cap_unchanged = 2,

    wlanif_cap_invalid
} wlanif_capStateUpdate_e;

/**
 * @brief Enumerations for bandwidth (MHz) supported by STA
 */
typedef enum wlanif_chwidth_e {
    wlanif_chwidth_20,
    wlanif_chwidth_40,
    wlanif_chwidth_80,
    wlanif_chwidth_160,

    wlanif_chwidth_invalid
} wlanif_chwidth_e;

/**
 * @brief Enumerations for IEEE802.11 PHY mode
 */
typedef enum wlanif_phymode_e {
    wlanif_phymode_basic,
    wlanif_phymode_ht,
    wlanif_phymode_vht,
    wlanif_phymode_he,

    wlanif_phymode_invalid
} wlanif_phymode_e;

/**
 * @brief PHY capabilities supported by a VAP or client
 */
typedef struct wlanif_phyCapInfo_t {
    /// Flag indicating if this PHY capability entry is valid or not
    LBD_BOOL valid : 1;

    /// The maximum bandwidth supported by this STA
    wlanif_chwidth_e maxChWidth : 3;

    /// The spatial streams supported by this STA
    u_int8_t numStreams : 4;

    /// The PHY mode supported by this STA
    wlanif_phymode_e phyMode : 8;

    /// The maximum MCS supported by this STA
    u_int8_t maxMCS;

    /// The maximum TX power supporetd by this STA
    u_int8_t maxTxPower;
} wlanif_phyCapInfo_t;

// Max number of spatial streams supported
#define WLANIF_MAX_NUM_STREAMS 0xF
// Max MCS if running in wlanif_phyMode_ht mode
#define WLANIF_MAX_MCS_HT 7
// Max Tx power supported
#define WLANIF_MAX_TX_POWER 0xFF

/**
 * @brief The format of the wlanif_event_assoc and wlanif_event_disassoc
 *        events.
 *
 * These events carry the same payload and thus share the same event
 * structure.
 */
typedef struct wlanif_assocEvent_t {
    /// Address of the STA that associated/disassociated.
    struct ether_addr sta_addr;

    /// The BSS on which the change occurred
    lbd_bssInfo_t bss;

    /// Indicate if BTM is supported (set to wlanif_cap_unchanged if unknown at this time)
    wlanif_capStateUpdate_e btmStatus;

    /// Indicate if RRM is supported (set to wlanif_cap_unchanged if unknown at this time)
    wlanif_capStateUpdate_e rrmStatus;

    /// Indicate if MU-MIMO is supported
    wlanif_capStateUpdate_e isMUMIMOSupported;

    /// Indicate if the STA is operating in static SMPS mode
    wlanif_capStateUpdate_e isStaticSMPS;

    /// PHY capabilities supported
    wlanif_phyCapInfo_t phyCapInfo;

    /// STA band capability bitmap
    u_int8_t bandCap;

    /// STA class
    u_int8_t sta_class;
} wlanif_assocEvent_t;

/**
 * @brief The format of the wlanif_event_chan_util event.
 */
typedef struct wlanif_chanUtilEvent_t {
    /// The BSS on which the STA is associated.
    lbd_bssInfo_t bss;

    /// The channel utilization as a percentage.
    u_int8_t utilization;
} wlanif_chanUtilEvent_t;

/**
 * @brief The format of the wlanif_vap_restart event.
 */
typedef struct wlanif_vapRestartEvent_t {
    /// The band on which the VAP was restarted.
    wlanif_band_e band;
} wlanif_vapRestartEvent_t;

/**
 * @brief Enum types denote crossing direction
 */
typedef enum {
    wlanif_xing_unchanged = 0,
    wlanif_xing_up = 1,
    wlanif_xing_down = 2,

    wlanif_xing_invalid
} wlanif_xingDirection_e;

/**
 * @brief The format of the wlanif_event_rssi_xing event
 */
typedef struct wlanif_rssiXingEvent_t {
    /// Address of the STA whose RSSI is reported.
    struct ether_addr sta_addr;

    /// The BSS on which the STA is associated.
    lbd_bssInfo_t bss;

    /// The RSSI measurement
    u_int8_t rssi;

    /// Flag indicating if it crossed inactivity RSSI threshold
    wlanif_xingDirection_e inactRSSIXing;

    /// Flag indicating if it crossed low RSSI threshold
    wlanif_xingDirection_e lowRSSIXing;

    /// Flag indicating if it crossed the rate based RSSI threshold
    wlanif_xingDirection_e rateRSSIXing;

    /// Flag indicating if it crossed the ap steering RSSI threshold
    wlanif_xingDirection_e apRSSIXing;
} wlanif_rssiXingEvent_t;

/**
 * @brief The format of the wlanif_event_rssi_xing event
 */
typedef struct wlanif_rssiXingEventMap_t {
    /// Address of the STA whose RSSI is reported.
    struct ether_addr sta_addr;

    /// The BSS on which the STA is associated.
    lbd_bssInfo_t bss;

    /// The RSSI measurement
    u_int8_t rssi;

    /// Flag indicating direction of change in RSSI threshold
    wlanif_xingDirection_e mapRssiXing;

} wlanif_rssiXingEventMap_t;

/**
 * @brief The format of the wlanif_event_tx_rate_xing event
 */
typedef struct wlanif_txRateXingEvent_t {
    /// Address of the STA whose Tx rate is reported.
    struct ether_addr sta_addr;

    /// The BSS on which the STA is associated.
    lbd_bssInfo_t bss;

    /// The Tx rate (Kbps).
    u_int32_t tx_rate;

    /// Flag indicating direction of the crossing.
    wlanif_xingDirection_e xing;
} wlanif_txRateXingEvent_t;

/**
 * @brief The format of the wlanif_event_rssi_measurement event
 */
typedef struct wlanif_rssiMeasurementEvent_t {
    /// Address of the STA whose RSSI is reported.
    struct ether_addr sta_addr;

    /// The BSS on which the STA is associated.
    lbd_bssInfo_t bss;

    /// The RSSI measurement
    u_int8_t rssi;
} wlanif_rssiMeasurementEvent_t;

/**
 * @brief The format of the wlanif_event_band_steering_state event.
 */
typedef struct wlanif_bandSteeringStateEvent_t {
    /// Whether band steering is enabled.
    LBD_BOOL enabled;
} wlanif_bandSteeringStateEvent_t;

#if SONLIB_SUPPORT_ENABLED

/**
 * @brief BSS Transition Management response status codes
 * Taken from 802.11v standard
 */
enum IEEE80211_WNM_BSTM_RESP_STATUS {
    IEEE80211_WNM_BSTM_RESP_SUCCESS,
    IEEE80211_WNM_BSTM_RESP_REJECT_UNSPECIFIED,
    IEEE80211_WNM_BSTM_RESP_REJECT_INSUFFICIENT_BEACONS,
    IEEE80211_WNM_BSTM_RESP_REJECT_INSUFFICIENT_CAPACITY,
    IEEE80211_WNM_BSTM_RESP_REJECT_BSS_TERMINATION_UNDESIRED,
    IEEE80211_WNM_BSTM_RESP_REJECT_BSS_TERMINATION_DELAY,
    IEEE80211_WNM_BSTM_RESP_REJECT_STA_CANDIDATE_LIST_PROVIDED,
    IEEE80211_WNM_BSTM_RESP_REJECT_NO_SUITABLE_CANDIDATES,
    IEEE80211_WNM_BSTM_RESP_REJECT_LEAVING_ESS,

    IEEE80211_WNM_BSTM_RESP_INVALID
};

/* BSTM MBO/QCN Transition Rejection Reason Code */
enum IEEE80211_BSTM_REJECT_REASON_CODE {
    IEEE80211_BSTM_REJECT_REASON_UNSPECIFIED,
    IEEE80211_BSTM_REJECT_REASON_FRAME_LOSS_RATE,        /* Excessive frame loss rate is expected by STA */
    IEEE80211_BSTM_REJECT_REASON_DELAY_FOR_TRAFFIC,      /* Excessive traffic delay will be incurred this time */
    IEEE80211_BSTM_REJECT_REASON_INSUFFICIENT_CAPACITY,  /* Insufficient QoS capacity for current traffic stream expected by STA */
    IEEE80211_BSTM_REJECT_REASON_LOW_RSSI,               /* STA receiving low RSSI in frames from suggested channel(s) */
    IEEE80211_BSTM_REJECT_REASON_HIGH_INTERFERENCE,      /* High Interference is expected at the candidate channel(s) */
    IEEE80211_BSTM_REJECT_REASON_SERVICE_UNAVAILABLE,    /* Required services by STA are not available on requested channel */

    IEEE80211_BSTM_REJECT_REASON_INVALID                 /* value 7 - 255 is reserved and considered invalid */
};

#define IEEE80211_BSTEERING_RRM_NUM_BCNRPT_MAX 8

#endif

/**
 * @brief The format of the wlanif_event_btm_response event.
 */
typedef struct wlanif_btmResponseEvent_t {
    /// The BSS on which the response was received
    lbd_bssInfo_t bss;

    /// Token for the corresponding request frame.
    u_int8_t dialog_token;

    /// MAC address of the sending station.
    struct ether_addr sta_addr;

    /// Status of the response to the request frame.
    ///
    /// The values are identical to those defined in the standard (see
    /// IEEE80211_WNM_BSTM_RESP_STATUS in the driver).
    u_int8_t status;

    /// BSTM Reject Reason Code sent by STA in BSTM Response
    ///
    /// The values are identical to those defined in the standard (see
    /// IEEE80211_BSTM_REJECT_REASON_CODE in the driver).
    u_int8_t reject_code;

    /// Number of minutes that the STA requests the BSS to delay termination.
    u_int8_t termination_delay;

    /// BSSID of the BSS that the STA transitions to.
   struct ether_addr target_bssid;
} wlanif_btmResponseEvent_t;

/**
 * @brief The format of the wlanif_event_btm_query event.
 */
typedef struct wlanif_btmQueryEvent_t {
    /// Token for the corresponding request frame.
    u_int8_t dialog_token;

    /// MAC address of the sending station.
    struct ether_addr sta_addr;

    /// BSTM query reason.
    u_int16_t reason;
} wlanif_btmQueryEvent_t;

/// Maximum number of beacon reports in a single event
#define WLANIF_NUM_BCNRPT_MAX 8

/**
 * @brief The format of the wlanif_event_beacon_report event.
 */
typedef struct wlanif_beaconReportEvent_t {
    /// Flag indicating if the beacon report is valid or not
    LBD_BOOL valid;

    /// MAC address of the STA where beacon report is received
    struct ether_addr sta_addr;

    struct {
        /// The first BSS reported in the beacon report message.
        lbd_bssInfo_t reportedBss;

        /// The RCPI measurement reported
        int8_t rcpi;
    } reportedBcnrptInfo[WLANIF_NUM_BCNRPT_MAX];

    /// Number of beacon report info contained in this event
    size_t numBcnrpt;
} wlanif_beaconReportEvent_t;

/**
 * @brief The format of the wlanif_event_beacon_frame_report event.
 */
typedef struct wlanif_beaconFrameReportEvent_t {
    /// Flag indicating if the beacon report is valid or not
    LBD_BOOL valid;

    /// MAC address of the STA where beacon report is received
    struct ether_addr sta_addr;
    /// Number of beacon frame report info contained in this event
    size_t numBcnrpt;
    /// data length
    u_int32_t dataLen;
    /// the variable size report data
    u_int8_t data[];
} wlanif_beaconFrameReportEvent_t;

/**
 * @brief The format of the wlanif_event_smps_update event
 */
typedef struct wlanif_smpsUpdateEvent_t {
    /// MAC address of the STA where SM Power Save mode is received
    struct ether_addr sta_addr;

    /// The BSS on which the STA is associated.
    lbd_bssInfo_t bss;

    /// Flag indicating if the STA is operating in Static SMPS mode
    LBD_BOOL isStatic;
} wlanif_smpsUpdateEvent_t;

/**
 * @brief The format of the wlanif_event_opmode_update event
 */
typedef struct wlanif_opmodeUpdateEvent_t {
    /// MAC address of the STA where operating mode notification is received
    struct ether_addr sta_addr;

    /// The BSS on which the STA is associated.
    lbd_bssInfo_t bss;

    /// Max channel width reported in OP_MODE IE
    wlanif_chwidth_e maxChWidth;

    /// Number of spatial stream reported in OP_MODE IE
    u_int8_t numStreams;
} wlanif_opmodeUpdateEvent_t;

typedef struct wlanif_classGroupUpdateEvent_t {
    /// MAC address of the STA where operating mode notification is received
    struct ether_addr sta_addr;

    /// Classification group the client belongs to
    u_int8_t clientClassGroup;
} wlanif_classGroupUpdateEvent_t;

#define WLANIF_MAX_RADIO_OPER_CHAN 4

/**
 * @brief The format of the wlanif_event_radio_oper_chan_update event.
 */
typedef struct wlanif_radioOperChanUpdateEvent_t {
    /// MAC address of the radio where the update happened
    struct ether_addr radioAddr;

    /// The number of (operating class, channel) pairs that follow
    u_int8_t numChans;

    struct {
        /// The operating class associated with this channel number
        u_int8_t opClass;

        /// The channel number
        u_int8_t channel;
    } channels[WLANIF_MAX_RADIO_OPER_CHAN];

    /// The current TX power (in dBm)
    u_int8_t txPower;
} wlanif_radioOperChanUpdateEvent_t;

/**
 * @brief Snapshot of relevant per-STA statistics (needed for
 *        IAS).
 */
typedef struct wlanif_staStats_t {
    /// The Tx byte count
    u_int64_t txByteCount;
    /// The Rx byte count
    u_int64_t rxByteCount;
    /// The Tx packet count
    u_int32_t txPacketCount;
    /// The Rx packet count
    u_int32_t rxPacketCount;
    /// The last Tx rate (in Mbps)
    lbd_linkCapacity_t txRate;
    /// Uplink RSSI
    lbd_rssi_t rssi;
    /// PER
    u_int8_t per;
    ///ACK RSSI
    u_int32_t ack_rssi;
} wlanif_staStats_t;

/**
 * @brief Enum that indicates the beacon metrics report detail.
 */
typedef enum wlanif_bcnMetricQueryRptDetail_e {
    /// No fixed length fields or elements
    wlanif_bcnMetricQueryRptDetail_NoFieldsOrElements,

    /// All fixed length fields and any requested elements in the
    /// Request information element if present
    wlanif_bcnMetricQueryRptDetail_AllFieldsReqElements,

    /// All fixed length fields and elements (default, used when
    /// Reporting Detail subelement is not included in Beacon Request)
    wlanif_bcnMetricQueryRptDetail_AllFieldsAndElements,

    /// All values from this point onwards are reserved
    wlanif_bcnMetricQueryRptDetail_Max
} wlanif_bcnMetricQueryRptDetail_e;

/**
 * @brief Representation of the beacon metrics query
 */
typedef struct wlanif_bcnMetricsQuery_t {
    /// The MAC address of the STA for which beacon report is requested
    struct ether_addr staAddr;

    /// Operating class to be specified in the Beacon request
    u_int8_t opClass;

    /// Channel number to be specified in the Beacon request
    u_int8_t chanNum;

    /// BSSID to be specified in the Beacon request
    struct ether_addr bssid;

    /// Reporting Detail value to be specified in the Beacon Request
    /// One of wlanif_bcnMetricQueryRptDetail_e
    u_int8_t reportDetail;

    /// SSID length
    u_int8_t ssidLen;

    /// SSID
    char ssid[WLANIF_MAX_SSID_LEN];

    /// Number of AP Channel Reports
    u_int8_t numChanReport;

    struct {
        /// Length of an AP Channel Report
        u_int8_t lenChanReport;

        /// Operating Class in an AP Channel Report
        u_int8_t chanReportOpClass;

        /// Channel List in an AP Channel Report
        u_int8_t chanList[WLANIF_MAX_CHANNELS_PER_OP_CLASS];
    } chanReport[WLANIF_MAX_OPERATING_CLASSES];

    /// Number of element IDs
    u_int8_t numElementID;

    /// Element List
    u_int8_t elementList[];
} wlanif_bcnMetricsQuery_t;

/*
 * @brief Representation of Target BSSID to be used in BTM Request
 */
typedef struct wlanif_bssTargetInfo_t {
    /// The Target BSSID
    struct ether_addr bssidTarget;
    /// The Opclass for the operating channel
    u_int8_t opClass;
    /// The Channel on which the BSS is Operating
    u_int8_t opChannel;
} wlanif_bssTargetInfo_t;

/**
 * @brief Callback function when dumping the associated STAs.
 *
 * @param [in] addr  the MAC address of the associated STA
 * @param [in] bss  the bss the STA is associated to
 * @param [in] isBTMSupported set to LBD_TRUE if BTM is
 *                            supported, LBD_FALSE otherwise
 * @param [in] isRRMSupported set to LBD_TRUE if RRM is
 *                            supported, LBD_FALSE otherwise
 * @param [in] clientClassGroup client classification group the client belongs to
 * @param [in] isMUMIMOSupported set to LBD_TRUE if MU-MIMO is
 *                               supported, LBD_FALSE otherwise
 * @param [in] isStaticSMPS  set to LBD_TRUE if STA is operating in static SMPS mode
 * @param [in] phyCapInfo  PHY capabilities supported by each STA
 * @param [in] assocAge  the number of seconds elapsed since the STA associated
 * @param [in] cookie  the parameter provided in the dump call
 */
typedef void (*wlanif_associatedSTAsCB)(const struct ether_addr *addr, const lbd_bssInfo_t *bss,
                                        LBD_BOOL isBTMSupported, LBD_BOOL isRRMSupported,
                                        u_int8_t clientClassGroup,
                                        LBD_BOOL isMUMIMOSupported, LBD_BOOL isStaticSMPS,
                                        u_int8_t bandCap, const wlanif_phyCapInfo_t *phyCapInfo,
                                        time_t assocAge, void *cookie);

/**
 * @brief Callback function when dumping Airtime Fairness table
 *
 * @param [in] addr  the MAC address of the STA listed in ATF table
 * @param [in] bss  the BSS on which the airtime is reserved for this STA
 * @param [in] airtime  the reserved airtime listed in ATF table
 * @param [in] cookie  the parameter provided in the dump call
 */
typedef void (*wlanif_reservedAirtimeCB)(const struct ether_addr *addr,
                                         const lbd_bssInfo_t *bss,
                                         lbd_airtime_t airtime,
                                         void *cookie);

/**
 * @brief Function callback type that other modules can register to observe
 *        channel changes.
 *
 * @param [in] vap  the VAP on which channel change happens
 * @param [in] channelId  new channel
 * @param [in] cookie  the value provided by the caller when the observer
 *                     callback function was registered
 */
typedef void (*wlanif_chanChangeObserverCB)(lbd_vapHandle_t vap,
                                            lbd_channelId_t channelId,
                                            void *cookie);

/**
 * @brief Function callback type that other modules can register
 *        to receive notification when new STA stats are
 *        received from the driver.
 *
 * @param [in] addr  MAC address of the STA to which the stats
 *                   belong
 * @param [in] bss  BSS on which the stats were generated
 * @param [in] stats  pointer to struct containing stats
 * @param [in] cookie  the value provided by the caller when the observer
 *                     callback function was registered
 */
typedef void (*wlanif_staStatsObserverCB)(const struct ether_addr *addr,
                                          const lbd_bssInfo_t *bss,
                                          const wlanif_staStats_t *stats,
                                          void *cookie);

/**
 * @brief Snapshot of relevant per-STA statistics needed for load balancing and to report ap metric
 * to controller
 */
typedef struct wlanif_staStatsSnapshot_t {
    /// Number of bytes sent to the STA by this AP.
    u_int64_t txBytes;

    /// Number of bytes received from the STA by this AP.
    u_int64_t rxBytes;

    /// Last rate at which packets sent to the STA by this AP were sent.
    lbd_linkCapacity_t lastTxRate;

    /// Last rate at which the packets sent by the STA to this AP were sent.
    lbd_linkCapacity_t lastRxRate;

    /// most recent received packet RSSI from connected sta
    lbd_rssi_t updatedRSSI;

    /// Raw counter of the number of packets successfully sent
    u_int32_t packetsSent;

    /// Raw counter of the number of packets received from the associated
    u_int32_t packetsReceived;

    /// Raw counter of the number of packets which could not be transmitted
    u_int32_t txPacketsErrors;

    /// Raw counter of the number of packets which were received in error
    u_int32_t rxPacketsErrors;

    /// Raw counter of the number of packets sent with the retry flag set
    u_int32_t retransmissionCount;

    /// time at which the earliest measurement that contributed to the data rate estimates were
    /// made,
    u_int32_t timeDelta;
} wlanif_staStatsSnapshot_t;

// ====================================================================
// Public API
// ====================================================================

/**
 *
 *@brief Set flag to set select cfg80211 or wext
 *
 *@param [in] isCfg80211 1 for cfg80211; 0 for wext
 *
 */

void wlanif_setCfg80211 (int isCfg80211);

/**
 * @brief Initialize the library.
 *
 * Note that asynchronous events will not be enabled until the listen init
 * callbacks are invoked.
 *
 * @return LBD_OK on successful init; otherwise LBD_NOK
 */
LBD_STATUS wlanif_init(void);

/**
 * @brief Trigger the generation of events for changes in the radio operating
 *        channel.
 *
 * This is generally only invoked at startup time.
 *
 * @return LBD_OK on successful operation; otherwise LBD_NOK
 */
LBD_STATUS wlanif_generateRadioOperChanChangeEvents(void);

/**
 * @brief Update the AP steering RSSI threshold on the given radio to the
 *        desired value.
 *
 * @param [in] radioAddr  the MAC address of the radio
 * @param [in] rssi  the new RSSI value to use
 * @param [out] band  caller provided memory into which the band on which
 *                    the radio is operating should be placed
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_setAPSteeringRSSIThreshold(const struct ether_addr *radioAddr, lbd_rssi_t rssi,
                                             wlanif_band_e *band);

/**
 * @brief Update the RSSI reporting metrics on the given radio to the
 *        desired value.
 *
 * @param [in] radioAddr  the MAC address of the radio
 * @param [in] rssi  the new RSSI crossing threshold to use
 * @param [in] hysteresis  the amount the RSSI must have changed by (from
 *                         the point it was at the other side of the
 *                         threshold) for an event to be generated
 * @param [out] band  caller provided memory into which the band on which
 *                    the radio is operating should be placed
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_setRSSIMetricsReportingParams(const struct ether_addr *radioAddr, lbd_rssi_t rssi,
                                                u_int8_t hysteresis, wlanif_band_e *band);

/**
 * @brief Send a BSS Transition Management request frame to
 *        staAddr on the VAP it is associated to.
 *
 * @param [in] assocBSS  the BSS on which to send this request
 * @param [in] staAddr  the MAC address of the STA
 * @param [in] dialogToken dialog token to send with the request
 * @param [in] disassocTimer the disassocTimer to send with request
 * @param [in] disassocImminent the disassociation Imminent bit
 * @param [in] abridgedBit the abridged bit
 * @param [in] candidate contains target BSSID info for the request
 *
 * @return LBD_STATUS LBD_OK if sent successfully, LBD_NOK otherwise
 *
 */
LBD_STATUS wlanif_sendBTMRequestMap(const lbd_bssInfo_t *assocBSS, const struct ether_addr *staAddr,
                                    u_int8_t dialogToken, u_int16_t disassocTimer,
                                    LBD_BOOL disassocImminent, LBD_BOOL abridgedBit,
                                    const wlanif_bssTargetInfo_t *candidate);

/**
 * @brief Set overload status on a channel
 *
 * @param [in] channel  the channel on which to set overload status
 * @param [in] overload  LBD_TRUE for overload, LBD_FALSE for not overload
 *
 * @return LBD_OK on successfully set overload; otherwise LBD_NOK
 */
LBD_STATUS wlanif_setOverload(lbd_channelId_t channel, LBD_BOOL overload);

/**
 * @brief For each of the VAPs, dump the associated STAs and invoke the
 *        callback with each STA MAC address and the band on which it
 *        is associated.
 *
 * @param [in] callback  the callback to invoke with the associated STA
 *                       information
 * @param [in] cookie  the parameter to provide in the callback (in addition
 *                     to the STA information) for use by the caller of this
 *                     function
 *
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_dumpAssociatedSTAs(wlanif_associatedSTAsCB callback,
                                     void *cookie);

/**
 * @brief Request real-time RSSI measurement of a specific station
 *
 * The RSSI measurement will be reported back in wlanif_event_rssi_measurement.
 *
 * If the previous request has not completed in driver, this request will fail.
 *
 * @param [in] bss  the BSS that the client is associated with
 * @param [in] staAddr  the MAC address of the specific station
 * @param [in] numSamples  number of RSSI samples to average before reporting RSSI back
 *
 * @return  LBD_OK if the request is sent successfully; otherwise LBD_NOK
 */
LBD_STATUS wlanif_requestStaRSSI(const lbd_bssInfo_t *bss,
                                 const struct ether_addr * staAddr,
                                 u_int8_t numSamples);

/**
 * @brief Either enable or disable all VAPs on a channel in
 *        channelList for a STA.
 *
 * @param [in] channelCount number of channels in channelList
 * @param [in] channelList set of channels to enable or disable
 * @param [in] staAddr the MAC address of the STA
 * @param [in] Last ESS the STA was associated on
 * @param [in] enable set to LBD_TRUE to enable for all
 *             channels, LBD_FALSE to disable
 *
 * @return LBD_STATUS LBD_OK if the state could be set, LBD_NOK
 *                    otherwise
 */
LBD_STATUS wlanif_setChannelStateForSTA(
    u_int8_t channelCount,
    const lbd_channelId_t *channelList,
    const struct ether_addr *staAddr,
    lbd_essId_t lastServingESS,
    LBD_BOOL enable);

/**
 * @brief Either enable or disable all 2.4G VAPs on a channel in
 *        channelList for a STA.
 *
 * @param [in] channelCount number of channels in channelList
 * @param [in] channelList set of channels to enable or disable
 * @param [in] staAddr the MAC address of the STA
 * @param [in] enable set to LBD_TRUE to enable for all
 *             channels, LBD_FALSE to disable
 *
 * @return LBD_STATUS LBD_OK if the state could be set, LBD_NOK
 *                    otherwise
 */
LBD_STATUS wlanif_setChannelProbeStateForSTA(
    u_int8_t channelCount,
    const lbd_channelId_t *channelList,
    const struct ether_addr *staAddr,
    LBD_BOOL enable);

/**
 * @brief Will set the state of all VAPs on the same ESS not
 *        matching the candidate list.
 *
 * @param [in] candidateCount number of candidates in
 *                            candidateList
 * @param [in] candidateList set of candidate BSSes
 * @param [in] staAddr the MAC address of the STA
 * @param [in] lastServing ESS  Last ESS the STA was associated on
 * @param [in] enable if LBD_TRUE, will enable all VAPs not on
 *                    the candidate list, if LBD_FALSE will
 *                    disable.
 * @param [in] probeOnly if LBD_TRUE, will set the probe
 *                       response witholding state only
 * @param [in] servingBSSInfo Current info of the serving BSS
 * @param [in] clientClassGroup client classification group the client belongs to
 *
 * @return LBD_STATUS LBD_OK if the state could be set, LBD_NOK
 *                    otherwise
 */
LBD_STATUS wlanif_setNonCandidateStateForSTA(
    u_int8_t candidateCount,
    const lbd_bssInfo_t *candidateList,
    const struct ether_addr *staAddr,
    lbd_essId_t lastServingESS,
    LBD_BOOL enable,
    LBD_BOOL probeOnly,
    const lbd_bssInfo_t *servingBSSInfo,
    u_int8_t clientClassGroup);

/**
 * @brief Get all candidate BSSes on the same ESS not matching
 *        the candidate list
 *
 * @param [in] candidateCount number of candidates in
 *                            candidateList
 * @param [in] candidateList set of candidate BSSes
 * @param [in] maxCandidateCount  maximum number of candidate
 *                                BSSes that can be returned in
 *                                outCandidateList
 * @param [out] outCandidateList  set of candidate BSSes on the
 *                                same ESS but not matching the
 *                                candidate list
 * @param [in] servingBSSInfo Current info of the serving BSS
 *
 * @return Number of candidate BSSes added to outCandidateList
 */
u_int8_t wlanif_getNonCandidateStateForSTA(
    u_int8_t candidateCount,
    const lbd_bssInfo_t *candidateList,
    u_int8_t maxCandidateCount,
    lbd_bssInfo_t *outCandidateList,
    const lbd_bssInfo_t *servingBSSInfo);

/**
 * @brief Will update the state for all VAPs on the candidate
 *        list.
 *
 * @param [in] candidateCount number of candidates in
 *                            candidateList
 * @param [in] candidateList set of candidate BSSes
 * @param [in] staAddr the MAC address of the STA
 * @param [in] lastServing ESS  Last ESS the STA was associated on
 * @param [in] enable if LBD_TRUE, will enable all VAPs on
 *                    the candidate list, if LBD_FALSE will
 *                    disable.
 * @param [in] servingBSSInfo Current info of the serving BSS
 * @param [in] validitySecs seconds to block the STA. If 0 then
 *                          its infinitely valid
 * @param [in] clientClassGroup client classification group the client belongs to
 *
 * @return LBD_STATUS LBD_OK if the state could be set, LBD_NOK
 *                    otherwise
 */
LBD_STATUS wlanif_setCandidateStateForSTA(
    u_int8_t candidateCount,
    const lbd_bssInfo_t *candidateList,
    const struct ether_addr *staAddr,
    lbd_essId_t lastServingESS,
    LBD_BOOL enable,
    const lbd_bssInfo_t *servingBSSInfo,
    u_int16_t validitySecs,
    u_int8_t clientClassGroup);

/**
 * @brief Will update the probe state for all 2.4G VAPs on the
 *        candidate list.
 *
 * @param [in] candidateCount number of candidates in
 *                            candidateList
 * @param [in] candidateList set of candidate BSSes
 * @param [in] staAddr the MAC address of the STA
 * @param [in] enable if LBD_TRUE, will enable all VAPs on
 *                    the candidate list, if LBD_FALSE will
 *                    disable.
 *
 * @return LBD_STATUS LBD_OK if the state could be set, LBD_NOK
 *                    otherwise
 */
LBD_STATUS wlanif_setCandidateProbeStateForSTA(
    u_int8_t candidateCount,
    const lbd_bssInfo_t *candidateList,
    const struct ether_addr *staAddr,
    LBD_BOOL enable);

/**
 * @brief Determine if a BSSID identifies one of the candidates
 *        in a list.
 *
 * @param [in] candidateCount number of candidates in
 *                            candidateList
 * @param [in] candidateList set of candidate BSSes
 * @param [in] bssid  BSSID to search for
 *
 * @return LBD_TRUE if match is found; LBD_FALSE otherwise
 */
LBD_BOOL wlanif_isBSSIDInList(u_int8_t candidateCount,
                              const lbd_bssInfo_t *candidateList,
                              const struct ether_addr *bssid);

/**
 * @brief Resolve the BSSID for a given set of BSS info parameters.
 *
 * @param [in] bssInfo  the parameters to look up
 *
 * @return the BSSID, or NULL if it cannot be resolved
 */
const struct ether_addr *wlanif_getBSSIDForBSSInfo(
        const lbd_bssInfo_t *bssInfo);

/**
 * @brief Resolve the BSS info for a given local BSSID.
 *
 * @param [in] bssid  the BSSID to resolve
 * @param [out] bssInfo structure to be filled in with BSS info
 *
 * @return LBD_OK if the BSS was found; LBD_NOK otherwise
 */
LBD_STATUS wlanif_getBSSInfoFromBSSID(const struct ether_addr *bssid,
                                      lbd_bssInfo_t *bssInfo);

/**
 * @brief Get the set of channels that are active on this device
 *
 * @param [out] channelList  set of active channels
 * @param [out] chwidthList  set of channel width of all active channels
 * @param [in] maxSize  maximum number of channels that will be
 *                      returned
 *
 * @return count of active channels
 */
u_int8_t wlanif_getChannelList(lbd_channelId_t *channelList,
                               wlanif_chwidth_e *chwidthList,
                               u_int8_t maxSize);

/**
 * @brief Kick the STA out of the provided band, forcing disassociation.
 *
 * @param [in] assocBSS  the BSS on which the STA should be
 *                       disassociated
 * @param [in] staAddr the MAC address of the STA to disassociate
 * @param [in] local  set to LBD_TRUE if doing just a local
 *                    disassociation (no disassociation frame
 *                    sent OTA, only state cleaned up),
 *                    otherwise LBD_FALSE for a true
 *                    disassociation (sending disassociation
 *                    frame OTA)
 *
 * @return LBD_OK if the request to disassociate was successfully handled;
 *         otherwise LBD_NOK
 */
LBD_STATUS wlanif_disassociateSTA(const lbd_bssInfo_t *assocBSS,
                                  const struct ether_addr *staAddr,
                                  LBD_BOOL local);

/**
 * @brief Send a BSS Transition Management Request frame to a
 *        specific STA
 *
 * @param [in] assocBSS the BSS on which the STA is associated
 * @param [in] staAddr the MAC address of the STA to send the
 *                     request to
 * @param [in] dialogToken dialog token to send with the request
 * @param [in] candidateCount number of transition candidates to
 *                            include with the request
 * @param [in] candidates transition candidate list
 *
 * @return LBD_STATUS LBD_OK if the request was sent
 *                    successfully; otherwise LBD_NOK
 */
LBD_STATUS wlanif_sendBTMRequest(const lbd_bssInfo_t *assocBSS,
                                 const struct ether_addr *staAddr,
                                 u_int8_t dialogToken,
                                 u_int8_t candidateCount,
                                 u_int8_t steerReason,
                                 u_int8_t forceSteer,
                                 const lbd_bssInfo_t *candidateList);

/**
 * @brief Request the real-time downlink RSSI measurement of a specific
 *        client. This could be the RSSI seen by client from beacon or probe
 *        response
 *
 * The RSSI measurement will be reported back in wlanif_event_rssi_measurement.
 *
 * @param [in] bss  the BSS on which the STA is associated on
 * @param [in] staAddr  the MAC address of the STA
 * @param [in] rrmCapable  flag indicating if the STA implements 802.11k feature
 * @param [in] numChannels  number of channels in channelList
 * @param [in] channelList  set of channels to measure downlink RSSI
 * @param [in] clientClassGroup client classification group the client belongs to
 *
 * @return LBD_OK if the request has been sent successfully; otherwise
 *         return LBD_NOK
 */
LBD_STATUS wlanif_requestDownlinkRSSI(const lbd_bssInfo_t *bss,
                                      const struct ether_addr *staAddr,
                                      LBD_BOOL rrmCapable,
                                      size_t numChannels,
                                      const lbd_channelId_t *channelList,
                                      u_int8_t clientClassGroup);

/**
 * @brief Resolve band from channel number
 *
 * Only consider 2.4 GHz and 5 GHz band for now.
 *
 * @param [in] channum  the channel number
 *
 * @return the resolved band or wlanif_band_invalid
 */
wlanif_band_e wlanif_resolveBandFromChannelNumber(u_int8_t channum);

/**
 * @brief Enable the collection of byte and MCS statistics on the provided
 *        BSS.
 *
 * @param [in] bss  the BSS on which to enable the stats; this must be a
 *                  local BSS
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_enableSTAStats(const lbd_bssInfo_t *bss);

/**
 * @brief Take a snapshot of the STA statistics.
 *
 * @param [in] bss  the BSS that is serving the STA
 * @param [in] staAddr  the MAC address of the STA
 * @param [in] rateOnly will return only the rate data.  Does
 *                      not require stats to be enabled.
 * @param [out] staStats  the snapshot of the stats; only populated on success
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_sampleSTAStats(const lbd_bssInfo_t *bss,
                                 const struct ether_addr *staAddr,
                                 LBD_BOOL rateOnly,
                                 wlanif_staStatsSnapshot_t *staStats);

/**
 * @brief Disable the collection of byte and MCS statistics on the provided
 *        BSS.
 *
 * @param [in] bss  the BSS on which to disable the stats; this must be a
 *                  local BSS
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_disableSTAStats(const lbd_bssInfo_t *bss);

/**
 * @brief Obtain a copy of the PHY capabilities of a specific BSS.
 *
 * @param [in] bss  the BSS for which to obtain the capabilities
 * @param [out] phyCap  the PHY capabilities resolved on success
 *
 * @return LBD_OK if the PHY capabilities are resolved successfully;
 *         otherwise return LBD_NOK
 */
LBD_STATUS wlanif_getBSSPHYCapInfo(const lbd_bssInfo_t *bss,
                                   wlanif_phyCapInfo_t *phyCap);

/**
 * @brief Check if a given channel has the strongest Tx power on its band
 *
 * @param [in] channelId  the given channel
 * @param [out] isStrongest  set to LBD_TRUE if the channel has the highest Tx
 *                           power on its band on success
 *
 * @return LBD_OK on success; otherwise return LBD_NOK
 */
LBD_STATUS wlanif_isStrongestChannel(lbd_channelId_t channelId, LBD_BOOL *isStrongest);

/**
 * @brief Check if a given BSS is on the channel with the strongest Tx power
 *        on its band
 *
 * @param [in] bss  the given BSS
 * @param [out] isStrongest  set to LBD_TRUE if the channel has the highest Tx
 *                           power on its band on success
 *
 * @return LBD_OK on success; otherwise return LBD_NOK
 */
LBD_STATUS wlanif_isBSSOnStrongestChannel(const lbd_bssInfo_t *bss,
                                          LBD_BOOL *isStrongest);

/**
 * @brief For each of the VAPs, dump the Airtime Fainess (ATF) table and
 *        invoke the callback with each STA MAC address and the reserved
 *        airtime listed
 *
 * @param [in] callback  the callback to invoke with the reserved airtime
 *                       information
 * @param [in] cookie  the parameter to provide in the callback (in addition
 *                     to the airtime information) for use by the caller of this
 *                     function
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_dumpATFTable(wlanif_reservedAirtimeCB callback,
                               void *cookie);

/**
 * @brief Determine if STA is associated on a BSS
 *
 * @param [in] bss  BSS to check for STA association
 * @param [in] staAddr  MAC address of STA to check for
 *                      association
 *
 * @return LBD_TRUE if STA is associated on BSS; LBD_FALSE
 *         otherwise
 */
LBD_BOOL wlanif_isSTAAssociated(const lbd_bssInfo_t *bss,
                                const struct ether_addr *staAddr);

/**
 * @brief Register a callback function to observe channel changes
 *
 * Note that the pair of the callback and cookie must be unique.
 *
 * @param [in] callback  the function to invoke for channel changes
 * @param [in] cookie  the parameter to pass to the callback function
 *
 * @return LBD_OK if the observer was successfully registered; otherwise
 *         LBD_NOK (either due to no free slots or a duplicate registration)
 */
LBD_STATUS wlanif_registerChanChangeObserver(wlanif_chanChangeObserverCB callback,
                                             void *cookie);

/**
 * @brief Unregister a callback function so that it no longer will receive
 *        channel change notification.
 *
 * The parameters provided must match those given in the original
 * wlanif_registerChanChangeObserver() call.
 *
 * @param [in] callback  the function that was previously registered
 * @param [in] cookie  the parameter that was provided when the function was
 *                     registered
 *
 * @return LBD_OK if the observer was successfully unregistered; otherwise
 *         LBD_NOK
 */
LBD_STATUS wlanif_unregisterChanChangeObserver(wlanif_chanChangeObserverCB callback,
                                               void *cookie);

/**
 * @brief Register a callback function to observe STA stats
 *
 * @param [in] callback  the function to invoke for new STA
 *                       stats
 * @param [in] cookie  the parameter to pass to the callback function
 *
 * @return LBD_OK if the observer was successfully registered; otherwise
 *         LBD_NOK (due to no free slots)
 */
LBD_STATUS wlanif_registerSTAStatsObserver(wlanif_staStatsObserverCB callback,
                                           void *cookie);

/**
 * @brief Unregister a callback function so that it no longer will receive
 *        STA stats notification.
 *
 * The parameters provided must match those given in the original
 * wlanif_registerSTAStatsObserver() call.
 *
 * @param [in] callback  the function that was previously registered
 * @param [in] cookie  the parameter that was provided when the function was
 *                     registered
 *
 * @return LBD_OK if the observer was successfully unregistered; otherwise
 *         LBD_NOK
 */
LBD_STATUS wlanif_unregisterSTAStatsObserver(wlanif_staStatsObserverCB callback,
                                             void *cookie);

/**
 * @brief Find BSSes that are on the same band with the given BSS (except the given one)
 *
 * @param [in] bss  the given BSS
 * @param [in] band  if set to wlanif_band_invalid, find BSSes from both bands;
 *                   otherwise, find BSSes from the given band
 * @param [in] lastServingESS  if no given BSS, will find BSSes on this ESS
 * @param [inout] maxNumBSSes  on input, it is the maximum number of BSSes expected;
 *                             on output, return number of entries in the bssList
 * @param [out] bssList  the list of BSSes that are on the same band with given BSS
 *
 * @return LBD_OK on success, otherwise return LBD_NOK
 */
LBD_STATUS wlanif_getBSSesSameESS(
        const lbd_bssInfo_t *bss, lbd_essId_t lastServingESS,
        wlanif_band_e band, size_t* maxNumBSSes, lbd_bssInfo_t *bssList);

/**
 * @brief Find the interface status for a given BSS
 *
 * @param [in] bssInfo  the given BSS
 *
 * @return LBD_OK if interface is up, otherwise return LBD_NOK
 */
LBD_STATUS wlanif_getIfaceStatus(const lbd_bssInfo_t *bssInfo);

/**
 * @brief Determine the minimum capability set of the two provided and
 *        store it in the output parameter.
 *
 * @param [in] bssCap  the resolved capabilities of the BSS
 * @param [in] staCap  the resolved capabilities of the STA
 * @param [out] minCapp  the minimum capability set
 */
void wlanif_resolveMinPhyCap(const wlanif_phyCapInfo_t *bssCap,
                             const wlanif_phyCapInfo_t *staCap,
                             wlanif_phyCapInfo_t *minCap);

/**
 * @brief Notify driver if a given STA is being steered or not
 *
 * @param [in] addr  the MAC address of the given STA
 * @param [in] bss  the BSS where the given STA is associated
 * @param [in] steeringInProgress  whether the STA is being steered
 *
 * @return LBD_OK if the steering status of the driver has been updated
 *         successfully; otherwise return LBD_NOK
 */
LBD_STATUS wlanif_updateSteeringStatus(const struct ether_addr *addr,
                                       const lbd_bssInfo_t *bss,
                                       LBD_BOOL steeringInProgress);

/**
 * @brief Resolve 802.11 global regulatory class from Wi-Fi channel
 *        number
 *
 * @param [in] channel  the channel number
 * @param [out] regClass  the resolved regulatory class if success
 *
 * @return LBD_OK if regulatory class is resolved
 *         successfully; otherwise return LBD_NOK
 */
LBD_STATUS wlanif_resolveRegClass(u_int8_t channel, u_int8_t *regClass);

/**
 * @brief Resolve SSID from ESS ID
 *
 * @param [in] essId  the ESS ID to get the SSID for
 * @param [out] ssid  the SSID string to be populated
 * @param [inout] len  on input it is the max length of the output SSID
 *                     on output it is the length of the SSID for the given ESS
 *
 * @return LBD_OK if SSID is resolved successfully;
 *                otherwise return LBD_NOK
 */
LBD_STATUS wlanif_resolveSSID(lbd_essId_t essId, char *ssid, u_int8_t *len);

/**
 * @brief Terminate the library.
 *
 * @return LBD_OK on successful termination; otherwise LBD_NOK
 */
LBD_STATUS wlanif_fini(void);

#if SONLIB_SUPPORT_ENABLED
/* Driver Enums and structs needed by LBD when SON Lib   */
/* is enabled. Since SON lib does not include QCA driver */
/* headers, adding needed structs, enums here.           */

/* NOTE: These are replica copy of driver structs, enums.*/
/* If driver structs, enum changes, it needs to be added */
/* here also, to keep them in-sync.                      */

#define IEEE80211_NWID_LEN                  32
#define IEEE80211_ADDR_LEN                  6
#define ATF_ACTIVED_MAX_CLIENTS             50
#define ATF_ACTIVED_MAX_ATFGROUPS           8
#define ATF_CFG_NUM_VDEV                    16
#define ATF_CFG_GLOBAL_INDEX                0
#define ATF_PER_NOT_ALLOWED                 1
#define ATF_SSID_NOT_EXIST                  2
#define BSTEERING_INVALID_RSSI              0
#define NETLINK_BAND_STEERING_EVENT         21
#define BSTEERING_MAX_PEERS_PER_EVENT       3
#define IEEE80211_RRM_MEASRPT_MODE_SUCCESS  0x00
#define MAC_ADDR_LEN                        6
#define LTEU_MAX_BINS                       10
#define MAX_SCAN_CHANS                      32
#define IEEE80211_RATE_MAXSIZE              44
#define MAX_CHAINS                          4
#define WME_NUM_AC                          4
//#define IFNAMSIZ        16

/* Channel width enum. Currently, SON expects bandwidth */
/* reported by driver to be one of this enum value.     */
/* Channel width is reported via "max_chwidth" field in */
/* struct soncmn_ieee80211_bsteering_datarate_info_t &  */
/* struct ieee80211_bsteering_datarate_info_t           */
enum ieee80211_cwm_width {
    IEEE80211_CWM_WIDTH20,
    IEEE80211_CWM_WIDTH40,
    IEEE80211_CWM_WIDTH80,
    IEEE80211_CWM_WIDTH160,
    IEEE80211_CWM_WIDTHINVALID = 0xff    /* user invalid value */
};


/* PHY mode enum. Currently, SON expects PHY mode from  */
/* driver to be one of this enum value. PHY mode is     */
/* reported via "phymode" field in following struct:    */
/* struct soncmn_ieee80211_bsteering_datarate_info_t &  */
/* struct ieee80211_bsteering_datarate_info_t           */
enum ieee80211_phymode {
    IEEE80211_MODE_AUTO             = 0,    /* autoselect */
    IEEE80211_MODE_11A              = 1,    /* 5GHz, OFDM */
    IEEE80211_MODE_11B              = 2,    /* 2GHz, CCK */
    IEEE80211_MODE_11G              = 3,    /* 2GHz, OFDM */
    IEEE80211_MODE_FH               = 4,    /* 2GHz, GFSK */
    IEEE80211_MODE_TURBO_A          = 5,    /* 5GHz, OFDM, 2x clock dynamic turbo */
    IEEE80211_MODE_TURBO_G          = 6,    /* 2GHz, OFDM, 2x clock dynamic turbo */
    IEEE80211_MODE_11NA_HT20        = 7,    /* 5Ghz, HT20 */
    IEEE80211_MODE_11NG_HT20        = 8,    /* 2Ghz, HT20 */
    IEEE80211_MODE_11NA_HT40PLUS    = 9,    /* 5Ghz, HT40 (ext ch +1) */
    IEEE80211_MODE_11NA_HT40MINUS   = 10,   /* 5Ghz, HT40 (ext ch -1) */
    IEEE80211_MODE_11NG_HT40PLUS    = 11,   /* 2Ghz, HT40 (ext ch +1) */
    IEEE80211_MODE_11NG_HT40MINUS   = 12,   /* 2Ghz, HT40 (ext ch -1) */
    IEEE80211_MODE_11NG_HT40        = 13,   /* 2Ghz, Auto HT40 */
    IEEE80211_MODE_11NA_HT40        = 14,   /* 2Ghz, Auto HT40 */
    IEEE80211_MODE_11AC_VHT20       = 15,   /* 5Ghz, VHT20 */
    IEEE80211_MODE_11AC_VHT40PLUS   = 16,   /* 5Ghz, VHT40 (Ext ch +1) */
    IEEE80211_MODE_11AC_VHT40MINUS  = 17,   /* 5Ghz  VHT40 (Ext ch -1) */
    IEEE80211_MODE_11AC_VHT40       = 18,   /* 5Ghz, VHT40 */
    IEEE80211_MODE_11AC_VHT80       = 19,   /* 5Ghz, VHT80 */
    IEEE80211_MODE_11AC_VHT160      = 20,   /* 5Ghz, VHT160 */
    IEEE80211_MODE_11AC_VHT80_80    = 21,   /* 5Ghz, VHT80_80 */
};

#define IEEE80211_MODE_MAX      (IEEE80211_MODE_11AC_VHT80_80 + 1)
#define IEEE80211_MODE_NONE      (IEEE80211_MODE_MAX + 1)


/* Phy mode enum as per 802.11mc Spec Anex C, used in RRM report */
/* These enum values are from standard, currently used in BSTM   */
/* Request to define Phy mode of candidate APs. BTM request is   */
/* sent by SON to driver during steering.                        */
enum ieee80211_phytype_mode {
    IEEE80211_PHY_TYPE_UNKNOWN = 0,
    IEEE80211_PHY_TYPE_FHSS = 1,        /* 802.11 2.4GHz 1997 */
    IEEE80211_PHY_TYPE_DSSS = 2,        /* 802.11 2.4GHz 1997 */
    IEEE80211_PHY_TYPE_IRBASEBAND = 3,
    IEEE80211_PHY_TYPE_OFDM  = 4,       /* 802.11ag */
    IEEE80211_PHY_TYPE_HRDSSS  = 5,     /* 802.11b 1999 */
    IEEE80211_PHY_TYPE_ERP  = 6,        /* 802.11g 2003 */
    IEEE80211_PHY_TYPE_HT   = 7,        /* 802.11n */
    IEEE80211_PHY_TYPE_DMG  = 8,        /* 802.11ad */
    IEEE80211_PHY_TYPE_VHT  = 9,        /* 802.11ac */
    IEEE80211_PHY_TYPE_TVHT  = 10,      /* 802.11af */
};


/* BSTM MBO/QCN Transition Request Reason Code.  */
/* These are as per standard, and currently      */
/* used by SON as reason code while sending BSTM */
/* to WLAN driver.                               */
enum IEEE80211_BSTM_REQ_REASON_CODE {
    IEEE80211_BSTM_REQ_REASON_UNSPECIFIED,
    IEEE80211_BSTM_REQ_REASON_FRAME_LOSS_RATE,
    IEEE80211_BSTM_REQ_REASON_DELAY_FOR_TRAFFIC,
    IEEE80211_BSTM_REQ_REASON_INSUFFICIENT_BANDWIDTH,
    IEEE80211_BSTM_REQ_REASON_LOAD_BALANCING,
    IEEE80211_BSTM_REQ_REASON_LOW_RSSI,
    IEEE80211_BSTM_REQ_REASON_EXCESSIVE_RETRANSMISSION,
    IEEE80211_BSTM_REQ_REASON_HIGH_INTERFERENCE,
    IEEE80211_BSTM_REQ_REASON_GRAY_ZONE,
    IEEE80211_BSTM_REQ_REASON_PREMIUM_AP,

    IEEE80211_BSTM_REQ_REASON_INVALID
};


/* Regulatory class value. These are used by SON */
/* to define regulatory class in Beacon request  */
/* from SON to driver during steering process.   */
/* Enum value used for "regclass" field in struct*/
/* soncmn_ieee80211_beaconreq_chaninfo           */
typedef enum {
    IEEE80211_RRM_REGCLASS_81 = 81,
    IEEE80211_RRM_REGCLASS_82 = 82,
    IEEE80211_RRM_REGCLASS_112 = 112,
    IEEE80211_RRM_REGCLASS_115 = 115,
    IEEE80211_RRM_REGCLASS_118 = 118,
    IEEE80211_RRM_REGCLASS_121 = 121,
    IEEE80211_RRM_REGCLASS_124 = 124,
    IEEE80211_RRM_REGCLASS_125 = 125,

    IEEE80211_RRM_REGCLASS_RESERVED
} IEEE80211_RRM_REGCLASS;

/* Beacon Request measurement mode enum. These  */
/* as per standard. SON uses these values while */
/* sending Beacon request to driver during      */
/* steering process.                            */
typedef enum {
    IEEE80211_RRM_BCNRPT_MEASMODE_PASSIVE = 0,
    IEEE80211_RRM_BCNRPT_MEASMODE_ACTIVE = 1,
    IEEE80211_RRM_BCNRPT_MEASMODE_BCNTABLE = 2,

    IEEE80211_RRM_BCNRPT_MEASMODE_RESERVED
} IEEE80211_RRM_BCNRPT_MEASMODE;


/* ACL policy enums. Currently used by SON */
/* internally and not communicated outside */
enum {
    IEEE80211_MACCMD_POLICY_OPEN    = 0,  /* set policy: no ACL's */
    IEEE80211_MACCMD_POLICY_ALLOW   = 1,  /* set policy: allow traffic */
    IEEE80211_MACCMD_POLICY_DENY    = 2,  /* set policy: deny traffic */
    IEEE80211_MACCMD_FLUSH          = 3,  /* flush ACL database */
    IEEE80211_MACCMD_DETACH         = 4,  /* detach ACL policy */
    IEEE80211_MACCMD_POLICY_RADIUS  = 5,  /* set policy: RADIUS managed ACLs */
};

#define    ieee80211_bstm_req_max_candidates 3
#define    IEEE80211_PARAM_SON                     429 /* Mark/query AP as SON enabled */
#define    IEEE80211_PARAM_ENABLE_OL_STATS         306   /*Enables/Disables the
                                                        stats in the Host and in the FW */
#define IEEE80211_DBGREQ_BSTEERING_SET_PARAMS      29 /* Set the static band steering parameters */
#define IEEE80211_DBGREQ_BSTEERING_GET_PARAMS      30
#define IEEE80211_DBGREQ_BSTEERING_ENABLE          33
#define IEEE80211_IOCTL_ATF_SHOWATFTBL             0xFF05
/* event code for Channel change  */
#define  IEEE80211_EV_CHAN_CHANGE                  28
/* enable ack RSSI */
#define IEEE80211_DBGREQ_BSTEERING_ENABLE_ACK_RSSI 101

/* Struct used for obtaining ATF information from driver  */
/* This is used only by QTI (not intended for 3rd party) */
struct atfcntbl{
    u_int8_t     ssid[IEEE80211_NWID_LEN+1];
    u_int8_t     sta_mac[IEEE80211_ADDR_LEN];
    u_int32_t    value;
    u_int8_t     info_mark;   /*0--vap, 1-sta*/
    u_int8_t     assoc_status;     /*1--Yes, 0 --No*/
    u_int8_t     all_tokens_used;  /*1--Yes, 0 --No*/
    u_int32_t    cfg_value;
    u_int8_t     grpname[IEEE80211_NWID_LEN+1];
};

struct atftable{
    u_int16_t         id_type;
    struct atfcntbl   atf_info[ATF_ACTIVED_MAX_CLIENTS+ATF_CFG_NUM_VDEV];
    u_int16_t         info_cnt;
    u_int8_t          atf_status;
    u_int32_t         busy;
    u_int32_t         atf_group;
    u_int8_t          show_per_peer_table;
};

#endif  /* SONLIB_SUPPORT_ENABLED */

/**
 * @brief Get the radio MAC address of BSS
 *
 * @param [in] bss  the BSS  this must be a local BSS
 * @param [out] radioAddr  Radio MAC address
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_getRadioAddrFromBSS(const lbd_bssInfo_t *bss, struct ether_addr *radioAddr);

/**
 * @brief Send beacon request with extended parameters to STA
 *
 * @param [in] staAddr  STA MAC address
 * @param [in] query  structure to create IE for beacon requuest
 * @param [in] bss  the BSS that is serving the STA
 * @param [in] clientClassGroup client classification group the client belongs to
 *
 * @return LBD_OK on success; otherwise LBD_NOK
 */
LBD_STATUS wlanif_sendBcnRequestExtended(const struct ether_addr *staAddr,
                                         const wlanif_bcnMetricsQuery_t *query,
                                         const lbd_bssInfo_t *bss,
                                         u_int8_t clientClassGroup);
#endif
